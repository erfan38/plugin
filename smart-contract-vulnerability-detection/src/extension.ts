// Import dependencies
import { OpenAIResponse } from './types'; // Import the interface
import { analyzeCode } from './apiHelper'; // Import the helper function
import * as vscode from 'vscode';

// Declare the Output Channel
const outputChannel = vscode.window.createOutputChannel('Vulnerability Detection Logs');

// Key for storing the API key in global state
const OPENAI_API_KEY_STORAGE_KEY = 'openaiApiKey';

// This method is called when your extension is activated
export function activate(context: vscode.ExtensionContext) {
    outputChannel.appendLine('Congratulations, your extension "smart-contract-vulnerability-detection" is now active!');

    // Command to Set API Key
    const setApiKeyCommand = vscode.commands.registerCommand('smart-contract-vulnerability-detection.setApiKey', async () => {
        const apiKey = await vscode.window.showInputBox({
            prompt: 'Enter your OpenAI API key',
            placeHolder: 'sk-xxxxxx',
            ignoreFocusOut: true,
            password: true, // Mask the input
        });

        if (apiKey) {
            context.globalState.update(OPENAI_API_KEY_STORAGE_KEY, apiKey);
            vscode.window.showInformationMessage('API key saved successfully!');
            outputChannel.appendLine('API key saved successfully!');
        } else {
            vscode.window.showWarningMessage('No API key entered.');
        }
    });

    // Command to Detect Vulnerabilities
    const detectVulnerabilities = vscode.commands.registerCommand(
        'smart-contract-vulnerability-detection.detectVulnerabilities',
        async () => {
            const editor = vscode.window.activeTextEditor;
            if (editor) {
                const code = editor.document.getText(); // Get the active file's content

                // Retrieve the API key
                const apiKey = context.globalState.get<string>(OPENAI_API_KEY_STORAGE_KEY);
                if (!apiKey) {
                    vscode.window.showErrorMessage('API key not set. Please use the "Set OpenAI API Key" command to enter your API key.');
                    outputChannel.appendLine('API key not set.');
                    return;
                }

                // Prompt the user to choose multiple vulnerability types
                const selectedVulnerabilities = await vscode.window.showQuickPick(
                    ['Integer Overflow/Underflow', 'Time Dependency', 'Reentrancy'],
                    {
                        placeHolder: 'Select vulnerability types to detect (Use Ctrl or Cmd to select multiple)',
                        canPickMany: true,
                    }
                );

                if (selectedVulnerabilities && selectedVulnerabilities.length > 0) {
                    outputChannel.appendLine(`Selected vulnerabilities: ${selectedVulnerabilities.join(', ')}`);
                    try {
                        const results = await detectVulnerabilitiesInCode(code, selectedVulnerabilities, apiKey);
                        if (results.length === 0) {
                            vscode.window.showInformationMessage('No vulnerabilities detected in the provided code.');
                            outputChannel.appendLine('No vulnerabilities detected.');
                        } else {
                            displayResults(results);
                        }
                    } catch (error: unknown) {
                        if (error instanceof Error) {
                            outputChannel.appendLine(`Error: ${error.message}`);
                            vscode.window.showErrorMessage(`Error: ${error.message}`);
                        } else {
                            const unknownErrorMessage = 'An unknown error occurred while analyzing the code.';
                            outputChannel.appendLine(unknownErrorMessage);
                            vscode.window.showErrorMessage(unknownErrorMessage);
                        }
                    }
                } else {
                    vscode.window.showErrorMessage('No vulnerabilities selected!');
                    outputChannel.appendLine('No vulnerabilities selected!');
                }
            } else {
                vscode.window.showErrorMessage('No active editor found!');
                outputChannel.appendLine('No active editor found!');
            }
        }
    );

    // Add commands to the subscriptions
    context.subscriptions.push(setApiKeyCommand, detectVulnerabilities);
}

// This method is called when your extension is deactivated
export function deactivate() {
    outputChannel.appendLine('Extension deactivated.');
}

// Function to detect vulnerabilities in the code
async function detectVulnerabilitiesInCode(
    code: string,
    vulnerabilityTypes: string[],
    apiKey: string
): Promise<any> {
    const fullPrompt = `Detect the following vulnerabilities in the code and provide a structured JSON response with start and end lines, reasons, risks, and fixes for each vulnerability type:
    
    Vulnerabilities: ${vulnerabilityTypes.join(", ")}

    Code:
    ${code}

    Response format:
    [
        {
            "vulnerabilityType": "<Type>",
            "vulnerableLines": "start-end",
            "vulnerabilityReason": "<Reason>",
            "potentialSecurityRisk": "<Risk>",
            "fixedCode": "<Fixed Code>"
        },
        ...
    ]`;

    outputChannel.appendLine(`Calling API with prompt: ${fullPrompt}`);

    try {
        const response: OpenAIResponse = await analyzeCode(apiKey, fullPrompt);

        if (!response.choices || !response.choices[0]?.message?.content) {
            throw new Error('Unexpected API response structure.');
        }

        return JSON.parse(response.choices[0].message.content);
    } catch (error: unknown) {
        if (error instanceof Error) {
            outputChannel.appendLine(`Error in detectVulnerabilitiesInCode: ${error.message}`);
            throw new Error(`Error while analyzing code: ${error.message}`);
        } else {
            const unknownErrorMessage = 'An unknown error occurred while analyzing the code.';
            outputChannel.appendLine(unknownErrorMessage);
            throw new Error(unknownErrorMessage);
        }
    }
}

// Function to display results in the Output Channel and as decorations in the editor
function displayResults(results: any[]) {
    outputChannel.clear();
    outputChannel.appendLine('Vulnerability Analysis Results:\n');

    const editor = vscode.window.activeTextEditor;
    if (!editor) {
        vscode.window.showErrorMessage('No active editor found to annotate results.');
        return;
    }

    const decorations: vscode.DecorationOptions[] = [];
    const decorationType = vscode.window.createTextEditorDecorationType({
        backgroundColor: 'rgba(255,0,0,0.3)',
        isWholeLine: true,
    });

    results.forEach((result) => {
        outputChannel.appendLine(
            `Type: ${result.vulnerabilityType}\n` +
            `Lines: ${result.vulnerableLines}\n` +
            `Reason: ${result.vulnerabilityReason}\n` +
            `Risk: ${result.potentialSecurityRisk}\n` +
            `Fix:\n${result.fixedCode}\n`
        );

        const [start, end] = result.vulnerableLines
            .split('-')
            .map((line: string) => parseInt(line, 10)); // Explicitly typed `line` as `string`
        const startPos = editor.document.lineAt(start - 1).range.start;
        const endPos = editor.document.lineAt(end - 1).range.end;

        decorations.push({
            range: new vscode.Range(startPos, endPos),
            hoverMessage: result.vulnerabilityReason,
        });
    });

    editor.setDecorations(decorationType, decorations);
}
