import { analyzeCode } from './apiHelper'; // Import the helper function
import * as vscode from 'vscode';
import { Generator } from './generator'; // Import Generator class

// Declare the Output Channel
const outputChannel = vscode.window.createOutputChannel('Vulnerability Detection Logs');

// Key for storing the API key in global state
const OPENAI_API_KEY_STORAGE_KEY = 'openaiApiKey';

// This method is called when your extension is activated
export function activate(context: vscode.ExtensionContext): void {
    outputChannel.appendLine('Congratulations, your extension "smart-contract-vulnerability-detection" is now active!');

    // Command to Set API Key
    const setApiKeyCommand = vscode.commands.registerCommand('smart-contract-vulnerability-detection.setApiKey', async () => {
        const apiKey = await vscode.window.showInputBox({
            prompt: 'Enter your OpenAI API key',
            placeHolder: 'sk-xxxxxx',
            ignoreFocusOut: true,
            password: true, // Mask the input
        });

        if (apiKey) {
            await context.globalState.update(OPENAI_API_KEY_STORAGE_KEY, apiKey);
            vscode.window.showInformationMessage('API key saved successfully!');
            outputChannel.appendLine('API key saved successfully!');
        } else {
            vscode.window.showWarningMessage('No API key entered.');
        }
    });

    // Command to Detect Vulnerabilities
    const detectVulnerabilities = vscode.commands.registerCommand(
        'smart-contract-vulnerability-detection.detectVulnerabilities',
        async () => {
            const editor = vscode.window.activeTextEditor;
            if (!editor) {
                vscode.window.showErrorMessage('No active editor found!');
                outputChannel.appendLine('No active editor found!');
                return;
            }

            const code = editor.document.getText(); // Get the active file's content
            const apiKey = context.globalState.get<string>(OPENAI_API_KEY_STORAGE_KEY);
            if (!apiKey) {
                vscode.window.showErrorMessage('API key not set. Please use the "Set OpenAI API Key" command.');
                outputChannel.appendLine('API key not set.');
                return;
            }

            // Prompt the user to choose multiple vulnerability types
            const selectedVulnerabilities = await vscode.window.showQuickPick(
                ['Integer Overflow/Underflow', 'Time Dependency', 'Reentrancy'],
                {
                    placeHolder: 'Select vulnerability types to detect (Use Ctrl or Cmd to select multiple)',
                    canPickMany: true,
                }
            );

            if (!selectedVulnerabilities || selectedVulnerabilities.length === 0) {
                vscode.window.showErrorMessage('No vulnerabilities selected!');
                outputChannel.appendLine('No vulnerabilities selected!');
                return;
            }

            outputChannel.appendLine(`Selected vulnerabilities: ${selectedVulnerabilities.join(', ')}`);
            try {
                const results = await detectVulnerabilitiesInCode(code, selectedVulnerabilities, apiKey);
                if (results.length === 0) {
                    vscode.window.showInformationMessage('No vulnerabilities detected in the provided code.');
                    outputChannel.appendLine('No vulnerabilities detected.');
                } else {
                    displayResults(results);
                }
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
                outputChannel.appendLine(`Error: ${errorMessage}`);
                vscode.window.showErrorMessage(`Error: ${errorMessage}`);
            }
        }
    );

    // Add commands to the subscriptions
    context.subscriptions.push(setApiKeyCommand, detectVulnerabilities);
}

// This method is called when your extension is deactivated
export function deactivate(): void {
    outputChannel.appendLine('Extension deactivated.');
}

// Function to detect vulnerabilities in the code
// async function detectVulnerabilitiesInCode(
//     code: string,
//     vulnerabilityTypes: string[],
//     apiKey: string
// ): Promise<any[]> {
//     let results: any[] = [];
//     for (const vulnerabilityType of vulnerabilityTypes) {
//         outputChannel.appendLine(`Analyzing for: ${vulnerabilityType}`);

//         try {
//             const response = await analyzeCode(apiKey, code, vulnerabilityType);

//             if (!response.choices || !response.choices[0]?.message?.content) {
//                 throw new Error('Unexpected API response structure.');
//             }

//             const parsedResults = JSON.parse(response.choices[0].message.content);
//             results.push(...parsedResults);
//         } catch (error) {
//             const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
//             outputChannel.appendLine(`Error analyzing ${vulnerabilityType}: ${errorMessage}`);
//         }
//     }

//     return results;
// }
async function detectVulnerabilitiesInCode(
    code: string,
    vulnerabilityTypes: string[],
    apiKey: string
): Promise<any[]> {
    let results: any[] = [];

    for (const vulnerabilityType of vulnerabilityTypes) {
        outputChannel.appendLine(`Analyzing for: ${vulnerabilityType}`);

        try {
            const generator = new Generator(apiKey, 'detector', vulnerabilityType);
            generator.createPrompt([], code);

            const responseContent = await generator.generate();
            const parsedResults = JSON.parse(responseContent);

            results.push(...parsedResults);
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
            outputChannel.appendLine(`Error analyzing ${vulnerabilityType}: ${errorMessage}`);
        }
    }

    return results;
}

// Function to display results
function displayResults(results: any[]): void {
    outputChannel.clear();
    outputChannel.appendLine('Vulnerability Analysis Results:\n');

    const editor = vscode.window.activeTextEditor;
    if (!editor) {
        vscode.window.showErrorMessage('No active editor found to annotate results.');
        return;
    }

    const decorations: vscode.DecorationOptions[] = [];
    const decorationType = vscode.window.createTextEditorDecorationType({
        backgroundColor: 'rgba(255,0,0,0.3)',
        isWholeLine: true,
    });

    results.forEach((result) => {
        outputChannel.appendLine(
            `Type: ${result.vulnerabilityType}\n` +
            `Lines: ${result.vulnerableLines}\n` +
            `Reason: ${result.vulnerabilityReason}\n` +
            `Risk: ${result.potentialSecurityRisk}\n` +
            `Fix:\n${result.fixedCode}\n`
        );

        const [start, end] = result.vulnerableLines.split('-').map((line: string) => parseInt(line, 10));
        const startPos = editor.document.lineAt(start - 1).range.start;
        const endPos = editor.document.lineAt(end - 1).range.end;

        decorations.push({
            range: new vscode.Range(startPos, endPos),
            hoverMessage: result.vulnerabilityReason,
        });
    });

    editor.setDecorations(decorationType, decorations);
}
