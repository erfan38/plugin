// //import { analyzeCode } from './apiHelper'; // Import the helper function
// import * as vscode from 'vscode';
// import { Generator } from './generator'; // Import Generator class
// import axios from 'axios'; // I am using this for api
// import * as fs from 'fs';
// import * as path from 'path';

// // Declare the Output Channel
// const outputChannel = vscode.window.createOutputChannel('Vulnerability Detection Logs');
// //outputChannel.appendLine('Congratulations, your extension "smart-contract-vulnerability-detection" is now active!');
// // Key for storing the API key in global state
// const OPENAI_API_KEY_STORAGE_KEY = 'openaiApiKey';

// // This method is called when your extension is activated
// export function activate(context: vscode.ExtensionContext): void {
//     outputChannel.appendLine('Extension "smart-contract-vulnerability-detection" is now active!');

//     // Command to Set API Key
//     const setApiKeyCommand = vscode.commands.registerCommand('smart-contract-vulnerability-detection.setApiKey', async () => {
//         const apiKey = await vscode.window.showInputBox({
//             prompt: 'Enter your OpenAI API key',
//             placeHolder: 'sk-xxxxxx',
//             ignoreFocusOut: true,
//             password: true, // Mask the input
//         });
    
//         if (apiKey) {
//             try {
//                 // Test the API key by making a minimal request
//                 const response = await axios.post(
//                     'https://api.openai.com/v1/chat/completions',
//                     {
//                         model: 'gpt-4',
//                         messages: [{ role: 'system', content: 'Test key validity' }],
//                         max_tokens: 1,
//                     },
//                     {
//                         headers: {
//                             'Authorization': `Bearer ${apiKey}`,
//                             'Content-Type': 'application/json',
//                         },
//                     }
//                 );
    
//                 if (response.status === 200) {
//                     // Save the key if the request is successful
//                     await context.globalState.update(OPENAI_API_KEY_STORAGE_KEY, apiKey);
//                     vscode.window.showInformationMessage('API key saved successfully!');
//                     outputChannel.appendLine('API key saved successfully!');
//                 } else {
//                     vscode.window.showErrorMessage('Invalid API key. Please try again.');
//                     outputChannel.appendLine('Invalid API key.');
//                 }
//             } catch (error) {
//                 vscode.window.showErrorMessage('Failed to validate the API key. Please try again.');
//                 console.error('API Key validation error:', error);
//             }
//         } else {
//             vscode.window.showWarningMessage('No API key entered.');
//         }
//     });

//     // Command to Detect Vulnerabilities
//     const detectVulnerabilities = vscode.commands.registerCommand(
//         'smart-contract-vulnerability-detection.detectVulnerabilities',
//         async () => {
//             const editor = vscode.window.activeTextEditor;
//             if (!editor) {
//                 vscode.window.showErrorMessage('No active editor found!');
//                 outputChannel.appendLine('No active editor found!');
//                 return;
//             }

//             const code = editor.document.getText(); // Get the active file's content
//             const apiKey = context.globalState.get<string>(OPENAI_API_KEY_STORAGE_KEY);
//             if (!apiKey) {
//                 vscode.window.showErrorMessage('API key not set. Please use the "Set OpenAI API Key" command.');
//                 outputChannel.appendLine('API key not set.');
//                 return;
//             }

//             // Prompt the user to choose multiple vulnerability types
//             const selectedVulnerabilities = await vscode.window.showQuickPick(
//                 ['Integer Overflow/Underflow', 'Time Dependency', 'Reentrancy'],
//                 {
//                     placeHolder: 'Select vulnerability types to detect (Use Ctrl or Cmd to select multiple)',
//                     canPickMany: true,
//                 }
//             );

//             if (!selectedVulnerabilities || selectedVulnerabilities.length === 0) {
//                 vscode.window.showErrorMessage('No vulnerabilities selected!');
//                 outputChannel.appendLine('No vulnerabilities selected!');
//                 return;
//             }

//             outputChannel.appendLine(`Selected vulnerabilities: ${selectedVulnerabilities.join(', ')}`);
//             try {
//                 const results = await detectVulnerabilitiesInCode(code, selectedVulnerabilities, apiKey);
//                 displayResults(results);
                
//                 if (results.length === 0) {
//                     vscode.window.showInformationMessage('No vulnerabilities detected in the provided code.');
//                     outputChannel.appendLine('No vulnerabilities detected.');
//                 } else {
//                     displayResults(results);
//                 }
//             } catch (error) {
//                 const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
//                 outputChannel.appendLine(`Error: ${errorMessage}`);
//                 vscode.window.showErrorMessage(`Error: ${errorMessage}`);
//             }
//         }
//     );

//     // Add commands to the subscriptions
//     context.subscriptions.push(setApiKeyCommand, detectVulnerabilities);
// }

// // This method is called when your extension is deactivated
// export function deactivate(): void {
//     outputChannel.appendLine('Extension deactivated.');
// }

// // Function to detect vulnerabilities in the code
// // async function detectVulnerabilitiesInCode(
// //     code: string,
// //     vulnerabilityTypes: string[],
// //     apiKey: string
// // ): Promise<any[]> {
// //     let results: any[] = [];
// //     for (const vulnerabilityType of vulnerabilityTypes) {
// //         outputChannel.appendLine(`Analyzing for: ${vulnerabilityType}`);

// //         try {
// //             const response = await analyzeCode(apiKey, code, vulnerabilityType);

// //             if (!response.choices || !response.choices[0]?.message?.content) {
// //                 throw new Error('Unexpected API response structure.');
// //             }

// //             const parsedResults = JSON.parse(response.choices[0].message.content);
// //             results.push(...parsedResults);
// //         } catch (error) {
// //             const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
// //             outputChannel.appendLine(`Error analyzing ${vulnerabilityType}: ${errorMessage}`);
// //         }
// //     }

// //     return results;
// // }
// async function detectVulnerabilitiesInCode(
//     code: string,
//     vulnerabilityTypes: string[],
//     apiKey: string
// ): Promise<any[]> {
//     //let results: any[] = [];
//     const results: any[] = [];
//     const dataPath = path.join(__dirname, 'data');

//     for (const vulnerabilityType of vulnerabilityTypes) {
//         outputChannel.appendLine(`Analyzing for: ${vulnerabilityType}`);
//          //const vulnerabilityKey = vulnerabilityType.toLowerCase().replace(/\s+/g, '_');
//          const vulnerabilityKey = vulnerabilityType.toLowerCase().replace(/\s+/g, '_');
//          const vulnerabilityFolder = path.join(dataPath, vulnerabilityKey);
//         console.log(`Vulnerability folder for ${vulnerabilityKey}:`, vulnerabilityFolder);

//         const samplePath = path.join(vulnerabilityFolder, `${vulnerabilityKey}_sample.sol`);
//         const instructionPath = path.join(vulnerabilityFolder, `${vulnerabilityKey}_instruction.txt`);
//         const jsonResponsePath = path.join(vulnerabilityFolder, `${vulnerabilityKey}_sample.json`);

//         if (!fs.existsSync(samplePath) || !fs.existsSync(instructionPath) || !fs.existsSync(jsonResponsePath)) {
//             vscode.window.showWarningMessage(`Missing data for ${vulnerabilityType}`);
//             outputChannel.appendLine(`Skipping ${vulnerabilityType} due to missing data.`) // to show :P
//             continue;
//         }
//         if (!fs.existsSync(instructionPath)) {
//             vscode.window.showWarningMessage(`Missing instruction file: ${instructionPath}`);
//             continue;
//         }

//         const trainCode = fs.readFileSync(samplePath, 'utf-8');
//         const instruction = fs.readFileSync(instructionPath, 'utf-8');
//         const trainResponse = fs.readFileSync(jsonResponsePath, 'utf-8');

//         try {
//             const generator = new Generator(apiKey, 'detector', vulnerabilityType, instruction);
//             const trainData: TrainData = {
//                 trainCode,
//                 trainResponse,
//             };
//             const exampleMessages: Message[] = [
//                 { role: 'user', content: trainCode },
//                 { role: 'assistant', content: trainResponse },
//             ];

//             generator.createPrompt(exampleMessages, code); //////////// start from here

//             const responseContent = await generator.generate();
//             //outputChannel.appendLine('answer');
//             //outputChannel.appendLine();
//             const parsedResults = JSON.parse(responseContent);

//             //results.push(...parsedResults);
//             results.push(...parsedResults);
//         } catch (error) {
//             const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
//             outputChannel.appendLine(`Error analyzing ${vulnerabilityType}: ${errorMessage}`);
//         }
//     }

//     return results;
// }

// // Function to display results
// function displayResults(results: any[]): void {
//     outputChannel.clear();
//     outputChannel.appendLine('Vulnerability Analysis Results:\n');

//     const editor = vscode.window.activeTextEditor;
//     if (!editor) {
//         vscode.window.showErrorMessage('No active editor found to annotate results.');
//         return;
//     }

//     const decorations: vscode.DecorationOptions[] = [];
//     const decorationType = vscode.window.createTextEditorDecorationType({
//         backgroundColor: 'rgba(255,0,0,0.3)',
//         isWholeLine: true,
//     });

//     results.forEach((result) => {
//         outputChannel.appendLine(
//             `Type: ${result.vulnerabilityType}\n` +
//             `Lines: ${result.vulnerableLines}\n` +
//             `Reason: ${result.vulnerabilityReason}\n` +
//             `Risk: ${result.potentialSecurityRisk}\n` +
//             `Fix:\n${result.fixedCode}\n`
//         );

//         const [start, end] = result.vulnerableLines.split('-').map((line: string) => parseInt(line, 10));
//         const startPos = editor.document.lineAt(start - 1).range.start;
//         const endPos = editor.document.lineAt(end - 1).range.end;

//         decorations.push({
//             range: new vscode.Range(startPos, endPos),
//             hoverMessage: `${result.vulnerabilityReason}\nRisk: ${result.potentialSecurityRisk}`,
//             //range: new vscode.Range(startPos, endPos),
//            // hoverMessage: result.vulnerabilityReason,
//         });
//     });

//     editor.setDecorations(decorationType, decorations);
// }



/////////////////////////////////// solving TrainData problem: 
import * as vscode from 'vscode';
import { Generator, TrainData } from './generator'; // Import Generator class
import axios from 'axios'; // For API calls
import * as fs from 'fs';
import * as path from 'path';

// Declare the Output Channel
const outputChannel = vscode.window.createOutputChannel('Vulnerability Detection Logs');
// Key for storing the API key in global state
const OPENAI_API_KEY_STORAGE_KEY = 'openaiApiKey';

// Extension activation
export function activate(context: vscode.ExtensionContext): void {
    outputChannel.appendLine('Extension "smart-contract-vulnerability-detection" is now active!');

    const setApiKeyCommand = vscode.commands.registerCommand(
        'smart-contract-vulnerability-detection.setApiKey',
        async () => {
            const apiKey = await vscode.window.showInputBox({
                prompt: 'Enter your OpenAI API key',
                placeHolder: 'sk-xxxxxx',
                ignoreFocusOut: true,
                password: true, // Mask the input
            });

            if (apiKey) {
                try {
                    const response = await axios.post(
                        'https://api.openai.com/v1/chat/completions',
                        {
                            model: 'gpt-4',
                            messages: [{ role: 'system', content: 'Test key validity' }],
                            max_tokens: 1,
                        },
                        {
                            headers: {
                                Authorization: `Bearer ${apiKey}`,
                                'Content-Type': 'application/json',
                            },
                        }
                    );

                    if (response.status === 200) {
                        await context.globalState.update(OPENAI_API_KEY_STORAGE_KEY, apiKey);
                        vscode.window.showInformationMessage('API key saved successfully!');
                        outputChannel.appendLine('API key saved successfully!');
                    } else {
                        vscode.window.showErrorMessage('Invalid API key. Please try again.');
                        outputChannel.appendLine('Invalid API key.');
                    }
                } catch (error) {
                    vscode.window.showErrorMessage('Failed to validate the API key. Please try again.');
                    console.error('API Key validation error:', error);
                }
            } else {
                vscode.window.showWarningMessage('No API key entered.');
            }
        }
    );

    const detectVulnerabilitiesCommand = vscode.commands.registerCommand(
        'smart-contract-vulnerability-detection.detectVulnerabilities',
        async () => {
            const editor = vscode.window.activeTextEditor;
            if (!editor) {
                vscode.window.showErrorMessage('No active editor found!');
                outputChannel.appendLine('No active editor found!');
                return;
            }

            const code = editor.document.getText();
            const apiKey = context.globalState.get<string>(OPENAI_API_KEY_STORAGE_KEY);
            if (!apiKey) {
                vscode.window.showErrorMessage('API key not set. Please use the "Set OpenAI API Key" command.');
                outputChannel.appendLine('API key not set.');
                return;
            }

            const selectedVulnerabilities = await vscode.window.showQuickPick(
                ['Integer Overflow/Underflow', 'Time Dependency', 'Reentrancy'],
                {
                    placeHolder: 'Select vulnerability types to detect (Use Ctrl or Cmd to select multiple)',
                    canPickMany: true,
                }
            );

            if (!selectedVulnerabilities || selectedVulnerabilities.length === 0) {
                vscode.window.showErrorMessage('No vulnerabilities selected!');
                outputChannel.appendLine('No vulnerabilities selected!');
                return;
            }

            outputChannel.appendLine(`Selected vulnerabilities: ${selectedVulnerabilities.join(', ')}`);

            try {
                const results = await detectVulnerabilitiesInCode(code, selectedVulnerabilities, apiKey);
                if (results.length === 0) {
                    vscode.window.showInformationMessage('No vulnerabilities detected in the provided code.');
                    outputChannel.appendLine('No vulnerabilities detected.');
                } else {
                    displayResults(results);
                }
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
                outputChannel.appendLine(`Error: ${errorMessage}`);
                vscode.window.showErrorMessage(`Error: ${errorMessage}`);
            }
        }
    );

    context.subscriptions.push(setApiKeyCommand, detectVulnerabilitiesCommand);
}

// Function to detect vulnerabilities
async function detectVulnerabilitiesInCode(
    code: string,
    vulnerabilityTypes: string[],
    apiKey: string
): Promise<any[]> {
    const results: any[] = [];
    const dataPath = path.join(__dirname, 'data');

    // Map vulnerability types to folder keys
    const vulnerabilityFolderMapping: { [key: string]: string } = {
        'Time Dependency': 'TD',
        'Reentrancy': 'RE',
        'Integer Overflow/Underflow': 'IoU',
    };

    for (const vulnerabilityType of vulnerabilityTypes) {
        console.log(`Analyzing for vulnerability type: ${vulnerabilityType}`);
        const vulnerabilityKey = vulnerabilityFolderMapping[vulnerabilityType];
        if (!vulnerabilityKey) {
            vscode.window.showWarningMessage(`No mapping found for vulnerability type: ${vulnerabilityType}`);
            console.log(`No mapping found for vulnerability type: ${vulnerabilityType}`);
            continue;
        }

        const vulnerabilityFolder = path.join(dataPath, vulnerabilityKey);
        console.log(`Vulnerability folder for ${vulnerabilityKey}: ${vulnerabilityFolder}`);

        const samplePath = path.join(vulnerabilityFolder, `${vulnerabilityKey}_sample.sol`);
        const instructionPath = path.join(vulnerabilityFolder, `${vulnerabilityKey}_instruction.txt`);
        const jsonResponsePath = path.join(vulnerabilityFolder, `${vulnerabilityKey}_sample.json`);

        // Log existence of each path
        console.log(`Sample Path Exists: ${fs.existsSync(samplePath)}`);
        console.log(`Instruction Path Exists: ${fs.existsSync(instructionPath)}`);
        console.log(`JSON Response Path Exists: ${fs.existsSync(jsonResponsePath)}`);

        if (!fs.existsSync(samplePath) || !fs.existsSync(instructionPath) || !fs.existsSync(jsonResponsePath)) {
            vscode.window.showWarningMessage(`Missing data for ${vulnerabilityType}`);
            console.log(`Skipping ${vulnerabilityType} due to missing data.`);
            continue;
        }

        const trainCode = fs.readFileSync(samplePath, 'utf-8');
        const instruction = fs.readFileSync(instructionPath, 'utf-8');
        const trainResponse = fs.readFileSync(jsonResponsePath, 'utf-8');

        try {
            const generator = new Generator(apiKey, 'detector', vulnerabilityType, instruction);
            const trainData: TrainData = {
                trainCode,
                trainResponse,
            };

            // Log training data
            console.log(`Train Code: ${trainCode}`);
            console.log(`Instruction: ${instruction}`);
            console.log(`Train Response: ${trainResponse}`);

            generator.createPrompt(trainData, code);

            // Log the constructed prompt
            console.log('Constructed Prompt Messages:', generator['messages']);

            const responseContent = await generator.generate();
            console.log('API Response Content:', responseContent);

            const parsedResults = JSON.parse(responseContent);
            results.push(...parsedResults);
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
            console.log(`Error analyzing ${vulnerabilityType}: ${errorMessage}`);
            outputChannel.appendLine(`Error analyzing ${vulnerabilityType}: ${errorMessage}`);
        }
    }

    return results;
}


// Function to display results
function displayResults(results: any[]): void {
    outputChannel.clear();
    outputChannel.appendLine('Vulnerability Analysis Results:\n');

    const editor = vscode.window.activeTextEditor;
    if (!editor) {
        vscode.window.showErrorMessage('No active editor found to annotate results.');
        return;
    }

    const decorations: vscode.DecorationOptions[] = [];
    const decorationType = vscode.window.createTextEditorDecorationType({
        backgroundColor: 'rgba(255,0,0,0.3)',
        isWholeLine: true,
    });

    results.forEach((result) => {
        outputChannel.appendLine(
            `Type: ${result.vulnerabilityType}\n` +
            `Lines: ${result.vulnerableLines}\n` +
            `Reason: ${result.vulnerabilityReason}\n` +
            `Risk: ${result.potentialSecurityRisk}\n` +
            `Fix:\n${result.fixedCode}\n`
        );

        const [start, end] = result.vulnerableLines.split('-').map((line: string) => parseInt(line, 10));
        const startPos = editor.document.lineAt(start - 1).range.start;
        const endPos = editor.document.lineAt(end - 1).range.end;

        decorations.push({
            range: new vscode.Range(startPos, endPos),
            hoverMessage: `${result.vulnerabilityReason}\nRisk: ${result.potentialSecurityRisk}`,
        });
    });

    editor.setDecorations(decorationType, decorations);
}
