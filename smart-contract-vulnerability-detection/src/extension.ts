// //import { analyzeCode } from './apiHelper'; // Import the helper function
// import * as vscode from 'vscode';
// import { Generator } from './generator'; // Import Generator class
// import axios from 'axios'; // I am using this for api
// import * as fs from 'fs';
// import * as path from 'path';

// // Declare the Output Channel
// const outputChannel = vscode.window.createOutputChannel('Vulnerability Detection Logs');
// //outputChannel.appendLine('Congratulations, your extension "smart-contract-vulnerability-detection" is now active!');
// // Key for storing the API key in global state
// const OPENAI_API_KEY_STORAGE_KEY = 'openaiApiKey';

// // This method is called when your extension is activated
// export function activate(context: vscode.ExtensionContext): void {
//     outputChannel.appendLine('Extension "smart-contract-vulnerability-detection" is now active!');

//     // Command to Set API Key
//     const setApiKeyCommand = vscode.commands.registerCommand('smart-contract-vulnerability-detection.setApiKey', async () => {
//         const apiKey = await vscode.window.showInputBox({
//             prompt: 'Enter your OpenAI API key',
//             placeHolder: 'sk-xxxxxx',
//             ignoreFocusOut: true,
//             password: true, // Mask the input
//         });
    
//         if (apiKey) {
//             try {
//                 // Test the API key by making a minimal request
//                 const response = await axios.post(
//                     'https://api.openai.com/v1/chat/completions',
//                     {
//                         model: 'gpt-4',
//                         messages: [{ role: 'system', content: 'Test key validity' }],
//                         max_tokens: 1,
//                     },
//                     {
//                         headers: {
//                             'Authorization': `Bearer ${apiKey}`,
//                             'Content-Type': 'application/json',
//                         },
//                     }
//                 );
    
//                 if (response.status === 200) {
//                     // Save the key if the request is successful
//                     await context.globalState.update(OPENAI_API_KEY_STORAGE_KEY, apiKey);
//                     vscode.window.showInformationMessage('API key saved successfully!');
//                     outputChannel.appendLine('API key saved successfully!');
//                 } else {
//                     vscode.window.showErrorMessage('Invalid API key. Please try again.');
//                     outputChannel.appendLine('Invalid API key.');
//                 }
//             } catch (error) {
//                 vscode.window.showErrorMessage('Failed to validate the API key. Please try again.');
//                 console.error('API Key validation error:', error);
//             }
//         } else {
//             vscode.window.showWarningMessage('No API key entered.');
//         }
//     });

//     // Command to Detect Vulnerabilities
//     const detectVulnerabilities = vscode.commands.registerCommand(
//         'smart-contract-vulnerability-detection.detectVulnerabilities',
//         async () => {
//             const editor = vscode.window.activeTextEditor;
//             if (!editor) {
//                 vscode.window.showErrorMessage('No active editor found!');
//                 outputChannel.appendLine('No active editor found!');
//                 return;
//             }

//             const code = editor.document.getText(); // Get the active file's content
//             const apiKey = context.globalState.get<string>(OPENAI_API_KEY_STORAGE_KEY);
//             if (!apiKey) {
//                 vscode.window.showErrorMessage('API key not set. Please use the "Set OpenAI API Key" command.');
//                 outputChannel.appendLine('API key not set.');
//                 return;
//             }

//             // Prompt the user to choose multiple vulnerability types
//             const selectedVulnerabilities = await vscode.window.showQuickPick(
//                 ['Integer Overflow/Underflow', 'Time Dependency', 'Reentrancy'],
//                 {
//                     placeHolder: 'Select vulnerability types to detect (Use Ctrl or Cmd to select multiple)',
//                     canPickMany: true,
//                 }
//             );

//             if (!selectedVulnerabilities || selectedVulnerabilities.length === 0) {
//                 vscode.window.showErrorMessage('No vulnerabilities selected!');
//                 outputChannel.appendLine('No vulnerabilities selected!');
//                 return;
//             }

//             outputChannel.appendLine(`Selected vulnerabilities: ${selectedVulnerabilities.join(', ')}`);
//             try {
//                 const results = await detectVulnerabilitiesInCode(code, selectedVulnerabilities, apiKey);
//                 displayResults(results);
                
//                 if (results.length === 0) {
//                     vscode.window.showInformationMessage('No vulnerabilities detected in the provided code.');
//                     outputChannel.appendLine('No vulnerabilities detected.');
//                 } else {
//                     displayResults(results);
//                 }
//             } catch (error) {
//                 const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
//                 outputChannel.appendLine(`Error: ${errorMessage}`);
//                 vscode.window.showErrorMessage(`Error: ${errorMessage}`);
//             }
//         }
//     );

//     // Add commands to the subscriptions
//     context.subscriptions.push(setApiKeyCommand, detectVulnerabilities);
// }

// // This method is called when your extension is deactivated
// export function deactivate(): void {
//     outputChannel.appendLine('Extension deactivated.');
// }

// // Function to detect vulnerabilities in the code
// // async function detectVulnerabilitiesInCode(
// //     code: string,
// //     vulnerabilityTypes: string[],
// //     apiKey: string
// // ): Promise<any[]> {
// //     let results: any[] = [];
// //     for (const vulnerabilityType of vulnerabilityTypes) {
// //         outputChannel.appendLine(`Analyzing for: ${vulnerabilityType}`);

// //         try {
// //             const response = await analyzeCode(apiKey, code, vulnerabilityType);

// //             if (!response.choices || !response.choices[0]?.message?.content) {
// //                 throw new Error('Unexpected API response structure.');
// //             }

// //             const parsedResults = JSON.parse(response.choices[0].message.content);
// //             results.push(...parsedResults);
// //         } catch (error) {
// //             const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
// //             outputChannel.appendLine(`Error analyzing ${vulnerabilityType}: ${errorMessage}`);
// //         }
// //     }

// //     return results;
// // }
// async function detectVulnerabilitiesInCode(
//     code: string,
//     vulnerabilityTypes: string[],
//     apiKey: string
// ): Promise<any[]> {
//     //let results: any[] = [];
//     const results: any[] = [];
//     const dataPath = path.join(__dirname, 'data');

//     for (const vulnerabilityType of vulnerabilityTypes) {
//         outputChannel.appendLine(`Analyzing for: ${vulnerabilityType}`);
//          //const vulnerabilityKey = vulnerabilityType.toLowerCase().replace(/\s+/g, '_');
//          const vulnerabilityKey = vulnerabilityType.toLowerCase().replace(/\s+/g, '_');
//          const vulnerabilityFolder = path.join(dataPath, vulnerabilityKey);
//         console.log(`Vulnerability folder for ${vulnerabilityKey}:`, vulnerabilityFolder);

//         const samplePath = path.join(vulnerabilityFolder, `${vulnerabilityKey}_sample.sol`);
//         const instructionPath = path.join(vulnerabilityFolder, `${vulnerabilityKey}_instruction.txt`);
//         const jsonResponsePath = path.join(vulnerabilityFolder, `${vulnerabilityKey}_sample.json`);

//         if (!fs.existsSync(samplePath) || !fs.existsSync(instructionPath) || !fs.existsSync(jsonResponsePath)) {
//             vscode.window.showWarningMessage(`Missing data for ${vulnerabilityType}`);
//             outputChannel.appendLine(`Skipping ${vulnerabilityType} due to missing data.`) // to show :P
//             continue;
//         }
//         if (!fs.existsSync(instructionPath)) {
//             vscode.window.showWarningMessage(`Missing instruction file: ${instructionPath}`);
//             continue;
//         }

//         const trainCode = fs.readFileSync(samplePath, 'utf-8');
//         const instruction = fs.readFileSync(instructionPath, 'utf-8');
//         const trainResponse = fs.readFileSync(jsonResponsePath, 'utf-8');

//         try {
//             const generator = new Generator(apiKey, 'detector', vulnerabilityType, instruction);
//             const trainData: TrainData = {
//                 trainCode,
//                 trainResponse,
//             };
//             const exampleMessages: Message[] = [
//                 { role: 'user', content: trainCode },
//                 { role: 'assistant', content: trainResponse },
//             ];

//             generator.createPrompt(exampleMessages, code); //////////// start from here

//             const responseContent = await generator.generate();
//             //outputChannel.appendLine('answer');
//             //outputChannel.appendLine();
//             const parsedResults = JSON.parse(responseContent);

//             //results.push(...parsedResults);
//             results.push(...parsedResults);
//         } catch (error) {
//             const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
//             outputChannel.appendLine(`Error analyzing ${vulnerabilityType}: ${errorMessage}`);
//         }
//     }

//     return results;
// }

// // Function to display results
// function displayResults(results: any[]): void {
//     outputChannel.clear();
//     outputChannel.appendLine('Vulnerability Analysis Results:\n');

//     const editor = vscode.window.activeTextEditor;
//     if (!editor) {
//         vscode.window.showErrorMessage('No active editor found to annotate results.');
//         return;
//     }

//     const decorations: vscode.DecorationOptions[] = [];
//     const decorationType = vscode.window.createTextEditorDecorationType({
//         backgroundColor: 'rgba(255,0,0,0.3)',
//         isWholeLine: true,
//     });

//     results.forEach((result) => {
//         outputChannel.appendLine(
//             `Type: ${result.vulnerabilityType}\n` +
//             `Lines: ${result.vulnerableLines}\n` +
//             `Reason: ${result.vulnerabilityReason}\n` +
//             `Risk: ${result.potentialSecurityRisk}\n` +
//             `Fix:\n${result.fixedCode}\n`
//         );

//         const [start, end] = result.vulnerableLines.split('-').map((line: string) => parseInt(line, 10));
//         const startPos = editor.document.lineAt(start - 1).range.start;
//         const endPos = editor.document.lineAt(end - 1).range.end;

//         decorations.push({
//             range: new vscode.Range(startPos, endPos),
//             hoverMessage: `${result.vulnerabilityReason}\nRisk: ${result.potentialSecurityRisk}`,
//             //range: new vscode.Range(startPos, endPos),
//            // hoverMessage: result.vulnerabilityReason,
//         });
//     });

//     editor.setDecorations(decorationType, decorations);
// }



/////////////////////////////////// solving TrainData problem: 
import * as vscode from 'vscode';
import { Generator, TrainData } from './generator'; // Import Generator class
import axios from 'axios'; // For API calls
import * as fs from 'fs';
import * as path from 'path';

class VulnerabilityPanel {
    public static currentPanel: VulnerabilityPanel | undefined;
    private readonly panel: vscode.WebviewPanel;
    private readonly extensionUri: vscode.Uri;
    private results: any[]; // Declare the results property

    private constructor(panel: vscode.WebviewPanel, extensionUri: vscode.Uri, results: any[]) {
        this.panel = panel;
        this.extensionUri = extensionUri;
        this.results = results; // Assign the passed results to the class property

        this.panel.onDidDispose(() => this.dispose(), null, []);

        // Listen for messages from the webview
        this.panel.webview.onDidReceiveMessage(
            (message) => {
                switch (message.command) {
                    case 'fixCode':
                        this.applyFix(message.index);
                        break;
                    case 'declineFix':
                        vscode.window.showInformationMessage('Fix declined.');
                        break;
                }
            },
            null,
            []
        );

        this.updateContent(results);
    }

    public static createOrShow(extensionUri: vscode.Uri, results: any[]) {
        if (VulnerabilityPanel.currentPanel) {
            VulnerabilityPanel.currentPanel.panel.reveal(vscode.ViewColumn.Beside);
            VulnerabilityPanel.currentPanel.updateContent(results);
            return;
        }

        const panel = vscode.window.createWebviewPanel(
            'vulnerabilityPanel',
            'Detected Vulnerabilities',
            vscode.ViewColumn.Beside,
            { enableScripts: true }
        );

        VulnerabilityPanel.currentPanel = new VulnerabilityPanel(panel, extensionUri, results);
    }

    private updateContent(results: any[]) {
        this.panel.webview.html = this.getWebviewContent(results);
    }

    private getWebviewContent(results: any[]) {
        const vulnerabilityItems = results.map((result, index) => `
            <div class="vulnerability">
                <div class="icon">⚠️</div>
                <div>
                    <div class="title">${result.vulnerabilityType || 'Unknown Vulnerability'}</div>
                    <div>${result.vulnerabilityReason || 'No explanation provided.'}</div>
                    <div class="actions">
                        <button onclick="fixCode(${index})">Fix Code</button>
                        <button onclick="declineFix(${index})">Decline</button>
                    </div>
                </div>
            </div>
        `).join('');

        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Detected Vulnerabilities</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 10px;
            color: #333;
            background-color: #1e1e1e;
        }
        .vulnerability {
            display: flex;
            align-items: center;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #2d2d2d;
            border-left: 4px solid #f39c12;
            color: #fff;
        }
        .icon {
            font-size: 24px;
            color: #f39c12;
            margin-right: 10px;
        }
        .title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .actions {
            margin-top: 10px;
        }
        button {
            margin-right: 10px;
            padding: 5px 10px;
            background-color: #4caf50;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        button.decline {
            background-color: #f44336;
        }
    </style>
</head>
<body>
    <h2 style="color: #fff;">Detected Vulnerabilities</h2>
    ${vulnerabilityItems}

    <script>
        const vscode = acquireVsCodeApi();

        function fixCode(index) {
            vscode.postMessage({ command: 'fixCode', index });
        }

        function declineFix(index) {
            vscode.postMessage({ command: 'declineFix', index });
        }
    </script>
</body>
</html>`;
    }

    private applyFix(index: number) {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active editor found to apply the fix.');
            return;
        }
    
        const fix = this.results[index].fixedCode;
        console.log('Fix Code:', fix);
        console.log('Vulnerable Lines:', this.results[index].vulnerableLines);
    
        const [start, end] = this.results[index].vulnerableLines.split('-').map((line: string) => parseInt(line, 10));
        console.log('Parsed Start Line:', start);
        console.log('Parsed End Line:', end);
    
        // Ensure line numbers are within bounds
        if (start < 1 || end > editor.document.lineCount) {
            vscode.window.showErrorMessage(`Invalid line numbers: ${start} - ${end}`);
            return;
        }
    
        const startPos = editor.document.lineAt(start - 1).range.start;
        const endPos = editor.document.lineAt(end - 1).range.end;
    
        editor.edit((editBuilder) => {
            editBuilder.replace(new vscode.Range(startPos, endPos), fix);
        });
    
        vscode.window.showInformationMessage('Fix applied successfully!');
    }
    
    

    public dispose() {
        VulnerabilityPanel.currentPanel = undefined;
        this.panel.dispose();
    }
}



// Declare the Output Channel
const outputChannel = vscode.window.createOutputChannel('Vulnerability Detection Logs');
// Key for storing the API key in global state
const OPENAI_API_KEY_STORAGE_KEY = 'openaiApiKey';

// Extension activation
export function activate(context: vscode.ExtensionContext): void {
    outputChannel.appendLine('Extension "smart-contract-vulnerability-detection" is now active!');

    const setApiKeyCommand = vscode.commands.registerCommand(
        'smart-contract-vulnerability-detection.setApiKey',
        async () => {
            const apiKey = await vscode.window.showInputBox({
                prompt: 'Enter your OpenAI API key',
                placeHolder: 'sk-xxxxxx',
                ignoreFocusOut: true,
                password: true, // Mask the input
            });

            if (apiKey) {
                try {
                    const response = await axios.post(
                        'https://api.openai.com/v1/chat/completions',
                        {
                            model: 'gpt-4',
                            messages: [{ role: 'system', content: 'Test key validity' }],
                            max_tokens: 1,
                        },
                        {
                            headers: {
                                Authorization: `Bearer ${apiKey}`,
                                'Content-Type': 'application/json',
                            },
                        }
                    );

                    if (response.status === 200) {
                        await context.globalState.update(OPENAI_API_KEY_STORAGE_KEY, apiKey);
                        vscode.window.showInformationMessage('API key saved successfully!');
                        outputChannel.appendLine('API key saved successfully!');
                    } else {
                        vscode.window.showErrorMessage('Invalid API key. Please try again.');
                        outputChannel.appendLine('Invalid API key.');
                    }
                } catch (error) {
                    vscode.window.showErrorMessage('Failed to validate the API key. Please try again.');
                    console.error('API Key validation error:', error);
                }
            } else {
                vscode.window.showWarningMessage('No API key entered.');
            }
        }
    );

    const detectVulnerabilitiesCommand = vscode.commands.registerCommand(
        'smart-contract-vulnerability-detection.detectVulnerabilities',
        async () => {
            const editor = vscode.window.activeTextEditor;
            if (!editor) {
                vscode.window.showErrorMessage('No active editor found!');
                outputChannel.appendLine('No active editor found!');
                return;
            }

            const code = editor.document.getText();
            const apiKey = context.globalState.get<string>(OPENAI_API_KEY_STORAGE_KEY);
            if (!apiKey) {
                vscode.window.showErrorMessage('API key not set. Please use the "Set OpenAI API Key" command.');
                outputChannel.appendLine('API key not set.');
                return;
            }

            const selectedVulnerabilities = await vscode.window.showQuickPick(
                ['Integer Overflow/Underflow', 'Time Dependency', 'Reentrancy'],
                {
                    placeHolder: 'Select vulnerability types to detect (Use Ctrl or Cmd to select multiple)',
                    canPickMany: true,
                }
            );

            if (!selectedVulnerabilities || selectedVulnerabilities.length === 0) {
                vscode.window.showErrorMessage('No vulnerabilities selected!');
                outputChannel.appendLine('No vulnerabilities selected!');
                return;
            }

            outputChannel.appendLine(`Selected vulnerabilities: ${selectedVulnerabilities.join(', ')}`);

            try {
                const results = await detectVulnerabilitiesInCode(code, selectedVulnerabilities, apiKey);
                console.log('Detected vulnerabilities:', results);

                if (results.length === 0) {
                    vscode.window.showInformationMessage('No vulnerabilities detected in the provided code.');
                    outputChannel.appendLine('No vulnerabilities detected.');
                } else {
                    displayResults(results);
                    VulnerabilityPanel.createOrShow(context.extensionUri, results);
                }
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
                outputChannel.appendLine(`Error: ${errorMessage}`);
                vscode.window.showErrorMessage(`Error: ${errorMessage}`);
            }
        }
    );

    context.subscriptions.push(setApiKeyCommand, detectVulnerabilitiesCommand);
}

// Function to detect vulnerabilities
async function detectVulnerabilitiesInCode(
    code: string,
    vulnerabilityTypes: string[],
    apiKey: string
): Promise<any[]> {
    const results: any[] = [];
    const dataPath = path.join(__dirname, 'data');

    // Map vulnerability types to folder keys
    const vulnerabilityFolderMapping: { [key: string]: string } = {
        'Time Dependency': 'TD',
        'Reentrancy': 'RE',
        'Integer Overflow/Underflow': 'IoU',
    };

    for (const vulnerabilityType of vulnerabilityTypes) {
        console.log(`Analyzing for vulnerability type: ${vulnerabilityType}`);
        const vulnerabilityKey = vulnerabilityFolderMapping[vulnerabilityType];
        if (!vulnerabilityKey) {
            vscode.window.showWarningMessage(`No mapping found for vulnerability type: ${vulnerabilityType}`);
            console.log(`No mapping found for vulnerability type: ${vulnerabilityType}`);
            continue;
        }

        const vulnerabilityFolder = path.join(dataPath, vulnerabilityKey);
        console.log(`Vulnerability folder for ${vulnerabilityKey}: ${vulnerabilityFolder}`);

        const samplePath = path.join(vulnerabilityFolder, `${vulnerabilityKey}_sample.sol`);
        const instructionPath = path.join(vulnerabilityFolder, `${vulnerabilityKey}_instruction.txt`);
        const jsonResponsePath = path.join(vulnerabilityFolder, `${vulnerabilityKey}_sample.json`);

        if (!fs.existsSync(samplePath) || !fs.existsSync(instructionPath) || !fs.existsSync(jsonResponsePath)) {
            vscode.window.showWarningMessage(`Missing data for ${vulnerabilityType}`);
            console.log(`Skipping ${vulnerabilityType} due to missing data.`);
            continue;
        }

        const trainCode = fs.readFileSync(samplePath, 'utf-8');
        const instruction = fs.readFileSync(instructionPath, 'utf-8');
        const trainResponse = fs.readFileSync(jsonResponsePath, 'utf-8');

        try {
            const generator = new Generator(apiKey, 'detector', vulnerabilityType, instruction);
            const trainData: TrainData = {
                trainCode,
                trainResponse,
            };

            generator.createPrompt(trainData, code);

            const responseContent = await generator.generate();
            console.log('API Response Content:', responseContent);

            const parsedResults = JSON.parse(responseContent);

            // Fallback logic to infer vulnerabilityType if it's missing
            const inferredVulnerabilityTypes = [
                { keyword: 'reentrancy', type: 'Reentrancy Attack' },
                { keyword: 'overflow', type: 'Integer Overflow' },
                { keyword: 'underflow', type: 'Integer Underflow' },
                { keyword: 'timestamp', type: 'Time Dependency' }
            ];

            parsedResults.forEach((result: any) => {
                if (!result.vulnerabilityType) {
                    for (const { keyword, type } of inferredVulnerabilityTypes) {
                        if (result.vulnerabilityReason.toLowerCase().includes(keyword)) {
                            result.vulnerabilityType = type;
                            break;
                        }
                    }
                    if (!result.vulnerabilityType) {
                        result.vulnerabilityType = 'Unknown Vulnerability';
                    }
                }
            });

            console.log('Parsed Results:', parsedResults);

            results.push(...parsedResults);
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
            console.log(`Error analyzing ${vulnerabilityType}: ${errorMessage}`);
            outputChannel.appendLine(`Error analyzing ${vulnerabilityType}: ${errorMessage}`);
        }
    }

    return results;
}


// Function to display results
function displayResults(results: any[]): void {
    outputChannel.clear();
    outputChannel.appendLine('Vulnerability Analysis Results:\n');

    const editor = vscode.window.activeTextEditor;
    if (!editor) {
        vscode.window.showErrorMessage('No active editor found to annotate results.');
        return;
    }

    const decorations: vscode.DecorationOptions[] = [];
    const decorationType = vscode.window.createTextEditorDecorationType({
        backgroundColor: 'rgba(255,0,0,0.3)',
        isWholeLine: true,
    });

    results.forEach((result) => {
        outputChannel.appendLine(
            `Type: ${result.vulnerabilityType}\n` +
            `Lines: ${result.vulnerableLines}\n` +
            `Reason: ${result.vulnerabilityReason}\n` +
            `Risk: ${result.potentialSecurityRisk}\n` +
            `Fix:\n${result.fixedCode}\n`
        );

        const [start, end] = result.vulnerableLines.split('-').map((line: string) => parseInt(line, 10));
        const startPos = editor.document.lineAt(start - 1).range.start;
        const endPos = editor.document.lineAt(end - 1).range.end;

        decorations.push({
            range: new vscode.Range(startPos, endPos),
            hoverMessage: `**${result.vulnerabilityType}**\n\n${result.vulnerabilityReason}\n\nRisk: ${result.potentialSecurityRisk}`
        });
        
    });

    editor.setDecorations(decorationType, decorations);
}
