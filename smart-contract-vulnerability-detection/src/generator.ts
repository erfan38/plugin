// generator.ts

import axios from 'axios'; // I am using this for api
//import * as vscode from 'vscode';

export interface TrainData { //I added this interface
    trainCode: string;
    trainResponse: string;
}

interface Message {
    role: 'system' | 'user' | 'assistant';
    content: string;
}

export class Generator {
    private apiKey: string;
    private messages: Message[];
    private role: 'detector' | 'uncommentor' | 'renamer';
    private vulnerability?: string;
    private formatter: string;
    private systemMessage: Message;
    private userPrefix: string;
    private instruction: string; // I added this
    

    constructor(apiKey: string, role: 'detector' | 'uncommentor' | 'renamer', vulnerability?: string, instruction: string = '') {
        this.apiKey = apiKey;
        this.messages = [];
        this.role = role;
        this.vulnerability = vulnerability;
        this.instruction = instruction;

        if (role === 'detector') {
            this.formatter = "Return the response in RFC8259 compliant JSON according to the ResponseFormat schema with no other text. The JSON format should provide reasons for each given lines of codes.";
            this.systemMessage = {
                role: 'system',
                content: "You are a cyber-security expert who analyzes and audits smart contracts. Find lines of code with vulnerabilities, reasons, and potential security risks.",
            };
            this.userPrefix = `In the code below, detect ${vulnerability} vulnerabilities through different lines of code. Give lines (start-end), explain the vulnerability reason, and describe the potential security risk it introduces.`;
            this.formatter = `Return the response in RFC8259 compliant JSON according to the schema:
            [
                {
                    "vulnerableLines": "l1-l2",
                    "vulnerabilityReason": "<Reason>",
                    "potentialSecurityRisk": "<Risk>",
                    "fixedCode": "<Function without vulnerability>"
                }
            ]`;
        } else if (role === 'uncommentor') {
            this.formatter = "Only write the code, do not use anything before and after the code.";
            this.systemMessage = {
                role: 'system',
                content: "You are a programmer who understands the code and can edit it.",
            };
            this.userPrefix = "Remove in-line and between lines comments of the smart contract code with .sol format. Do not change anything else in the code.";
            this.formatter = "Only return the uncommented code, without any explanation or additional text.";

        } else if (role === 'renamer') {
            const relatedWords: { [key: string]: string } = {
                IoU: '"intou", "vundflw", "bug", or "iou"',
                RE: '"bug", "re_ent", "re-entrancy", or "re"',
                TD: '"tmstmp", "td", or "bug"',
            };
            const fullName: { [key: string]: string } = {
                IoU: "Integer Overflow Underflow",
                RE: "Re-entrancy",
                TD: "Timestamp Dependency",
            };
            this.systemMessage = {
                role: 'system',
                content: "You are a programmer who assigns meaningful names to variables and functions in smart contracts.",
            };
            this.userPrefix = `Rename variables and functions in the code below to make them more meaningful, ensuring no names hint at the bug type (${relatedWords[vulnerability!]}). Do not change any logic.`;
            this.formatter = "Return the updated code without any explanation or additional text.";
         } else {
            throw new Error('Invalid role provided.');
        }
    }

    public setTargetVulnerability(vulnerability: string): void {
        this.vulnerability = vulnerability;
    }

    public setInstruction(instruction: string): void { //for instruction
        this.instruction = instruction;
    }

    public updateMessage(newMessage: Message): void {
        this.messages.push(newMessage);
    }

//     private getUserMessage(code: string): Message {
//         let userContent = '';

//         if (this.role === 'detector') {
//             userContent = `
// ${this.userPrefix}

// Smart Contract Code:
// ${code}

// ---
// ${this.formatter}
// ###`;
//         } else if (this.role === 'uncommentor' || this.role === 'renamer') {
//             userContent = `
// ${this.userPrefix}
// Smart Contract Code:
// ${code}`;
//         }

//         return {
//             role: 'user',
//             content: userContent,
//         };
//     }

private getUserMessage(code: string): Message {
    let userContent = '';

    if (this.role === 'detector') {
        userContent = `
${this.userPrefix}

Instruction:
${this.instruction}

Smart Contract Code:
${code}

---
${this.formatter}
###`;
    } else if (this.role === 'uncommentor' || this.role === 'renamer') {
        userContent = `
${this.userPrefix}
Smart Contract Code:
${code}`;
    }

    return {
        role: 'user',
        content: userContent,
    };
}

    // public createPrompt(exampleMessages: Message[], code: string): void {
    //     this.messages = [];
    //     this.messages.push(this.systemMessage);
    //     console.log('system message:',this.messages)
    //     if (exampleMessages && exampleMessages.length > 0) {
    //         this.messages.push(...exampleMessages);
    //         console.log('reach this if: ', exampleMessages)
    //     }
    //     console.log('example message: ', this.messages)
    //     const userMessage = this.getUserMessage(code);
    //     this.messages.push(userMessage);
    //     console.log('Constructed Prompt:', this.messages); // this line is for logging the constructed prompt for debugging
    // }
    public createPrompt(trainData: TrainData, code: string): void {
        this.messages = [];
        this.messages.push(this.systemMessage);
        console.log('system message:',this.messages)
        // Add example messages (training data)
        const trainUserMessage: Message = { role: 'user', content: trainData.trainCode };
        const trainAssistantMessage: Message = { role: 'assistant', content: trainData.trainResponse };
        this.messages.push(trainUserMessage, trainAssistantMessage);
    
        // Add user message with test code
        const userMessage = this.getUserMessage(code);
        this.messages.push(userMessage);
    
        console.log('Constructed Prompt:', this.messages);
    }

//     public async generate(): Promise<string> {
//         const response = await axios.post(
//             'https://api.openai.com/v1/chat/completions',
//             {
//                 model: 'gpt-4',
//                 messages: this.messages, //show this.message.....
//                 temperature: 1,
//                 max_tokens: 2048,
//                 top_p: 1.0,
//                 frequency_penalty: 0,
//                 presence_penalty: 0,
//             },
//             {
//                 headers: {
//                     'Authorization': `Bearer ${this.apiKey}`,
//                     'Content-Type': 'application/json',
//                 },
//             }
//         );

//         const answer = response.data.choices[0].message.content;
//         //outputChannel.appendLine('answer');
//         console.log(`answer:`)
//         console.log(answer)
//         return answer;
//     } catch (error: any) {
//         if (axios.isAxiosError(error)) {
//             // Log Axios-specific errors for debugging
//             console.error('API Request failed:', {
//                 status: error.response?.status,
//                 data: error.response?.data,
//             });
//             throw new Error(`OpenAI API call failed with status ${error.response?.status}: ${error.response?.data?.error?.message || 'Unknown error'}`);
//         } else {
//             // Handle generic errors
//             console.error('Unexpected error:', error);
//             throw new Error('An unexpected error occurred during the API call.');
//         }
//     }
// }

public async generate(): Promise<string> {
    let retries = 0;
    const maxRetries = 5;

    while (retries < maxRetries) {
        try {
            const response = await axios.post(
                'https://api.openai.com/v1/chat/completions',
                {
                    model: 'gpt-4',
                    messages: this.messages,
                    temperature: 1,
                    max_tokens: 2048,
                    top_p: 1.0,
                    frequency_penalty: 0,
                    presence_penalty: 0,
                },
                {
                    headers: {
                        Authorization: `Bearer ${this.apiKey}`,
                        'Content-Type': 'application/json',
                    },
                }
            );
            const answer = response.data.choices[0].message.content;
            console.log(`answer:`)
            console.log(answer)
            return answer;

        } catch (error: any) {
            if (axios.isAxiosError(error) && error.response?.status === 429) {
                console.log('Rate limit exceeded. Retrying...');
                retries++;
                await new Promise((resolve) => setTimeout(resolve, 2000)); // Wait 2 seconds before retrying
            } else {
                console.error('Unexpected error:', error);
                throw new Error('An unexpected error occurred during the API call.');
            }
        }
    }

    throw new Error('Max retries exceeded for OpenAI API call.');
}
}
